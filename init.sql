CREATE EXTENSION IF NOT EXISTS hstore;

-- Custom Types

CREATE TYPE user_level AS ENUM ('banned', 'default', 'verified', 'contributor', 'moderator', 'admin');
CREATE TYPE tag_type AS ENUM ('character', 'copyright', 'general', 'meta');

-- Tables

CREATE TABLE users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    email VARCHAR(64) NOT NULL UNIQUE,
    name VARCHAR(32) NOT NULL UNIQUE,
    level user_level DEFAULT 'default'
);

CREATE TABLE events (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- version INT GENERATED BY DEFAULT AS IDENTITY,
    user_id INTEGER REFERENCES users (id) NOT NULL,
    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    name VARCHAR(100) NOT NULL UNIQUE,
    currency CHAR(3),  -- ISO 4217
    hours TSTZMULTIRANGE
);

CREATE TABLE merchants (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- version INT GENERATED BY DEFAULT AS IDENTITY,
    user_id INTEGER REFERENCES users (id) NOT NULL,
    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    name VARCHAR(32) NOT NULL UNIQUE,
    urls HSTORE
);

CREATE TABLE listings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- version INT GENERATED BY DEFAULT AS IDENTITY,
    user_id INTEGER REFERENCES users (id) NOT NULL,
    event_id INTEGER REFERENCES events (id) NOT NULL,
    merchant_id INTEGER REFERENCES merchants (id) NOT NULL,
    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    price NUMERIC(12, 2)
);

CREATE TABLE tags (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- version INT GENERATED BY DEFAULT AS IDENTITY,
    user_id INTEGER REFERENCES users (id) NOT NULL,
    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    type tag_type DEFAULT 'general',
    name VARCHAR(48) NOT NULL UNIQUE
);

CREATE TABLE listing_tags (
    listing_id INTEGER REFERENCES listings (id),
    tag_id INTEGER REFERENCES tags (id),
    PRIMARY KEY (listing_id, tag_id)
);

CREATE TABLE comments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- version INT GENERATED BY DEFAULT AS IDENTITY,
    replying_to INTEGER REFERENCES comments (id) DEFAULT NULL,
    user_id INTEGER REFERENCES users (id) NOT NULL,
    listing_id INTEGER REFERENCES listings (id) NOT NULL,
    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL NOT NULL,
    content TEXT NOT NULL
);

CREATE TABLE comment_votes (
    user_id INTEGER REFERENCES users (id),
    comment_id INTEGER REFERENCES comments (id),
    value INTEGER,
    PRIMARY KEY (user_id, comment_id)
);

CREATE TABLE schedules (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INTEGER REFERENCES users (id) NOT NULL,
    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    name VARCHAR(64) NOT NULL
);

CREATE TABLE schedule_listings (
    schedule_id INTEGER REFERENCES schedules (id),
    listing_id INTEGER REFERENCES listings (id),
    target TIMESTAMP,  -- NULL is OK, means user hasn't decided
    PRIMARY KEY (schedule_id, listing_id)
);

CREATE TABLE favorites (
    user_id INTEGER REFERENCES users (id),
    listing_id INTEGER REFERENCES listings (id),
    PRIMARY KEY (user_id, listing_id)
);

-- Indexes

CREATE UNIQUE INDEX ON tags (name);

CREATE INDEX ON events (name);
CREATE INDEX ON listings (price);
CREATE INDEX ON tags (name);
CREATE INDEX ON comment_votes (comment_id);

-- Views

CREATE VIEW comment_scores AS
SELECT
  c.id AS comment_id,
  COALESCE(SUM(cv.value), 0) AS total_score
FROM comments c
LEFT JOIN comment_votes cv ON c.id = cv.comment_id
GROUP BY c.id;

-- Triggers

CREATE FUNCTION is_admin()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT level FROM users WHERE id = NEW.user_id) != 'admin' THEN
        RAISE EXCEPTION 'User must be an admin.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER is_admin_events
BEFORE INSERT ON events
FOR EACH ROW
EXECUTE FUNCTION is_admin();

CREATE FUNCTION is_verified()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT level FROM users WHERE id = NEW.user_id) < 'verified' THEN
        RAISE EXCEPTION 'User must be verified,';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER is_verified_merchants
BEFORE INSERT OR UPDATE ON merchants
FOR EACH ROW
EXECUTE FUNCTION is_verified();

CREATE TRIGGER is_verified_listings
BEFORE INSERT OR UPDATE ON listings
FOR EACH ROW
EXECUTE FUNCTION is_verified();

CREATE TRIGGER is_verified_tags
BEFORE INSERT OR UPDATE ON tags
FOR EACH ROW
EXECUTE FUNCTION is_verified();

CREATE TRIGGER is_verified_comments
BEFORE INSERT OR UPDATE ON comments
FOR EACH ROW
EXECUTE FUNCTION is_verified();

CREATE TRIGGER is_verified_comment_votes
BEFORE INSERT OR UPDATE ON comment_votes
FOR EACH ROW
EXECUTE FUNCTION is_verified();

CREATE FUNCTION validate_name()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.name !~ '^[a-z0-9_]+$' THEN
        RAISE EXCEPTION '"%" contains invalid characters.', NEW.name;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_user_name
BEFORE INSERT OR UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION validate_name();

CREATE TRIGGER validate_event_name
BEFORE INSERT OR UPDATE ON events
FOR EACH ROW
EXECUTE FUNCTION validate_name();

CREATE TRIGGER validate_merchant_name
BEFORE INSERT OR UPDATE ON merchants
FOR EACH ROW
EXECUTE FUNCTION validate_name();

CREATE TRIGGER validate_tag_name
BEFORE INSERT OR UPDATE ON tags
FOR EACH ROW
EXECUTE FUNCTION validate_name();

-- Procedures

CREATE PROCEDURE insert_listing_tags(
    p_user_id INTEGER,
    p_listing_id INTEGER,
    p_tags TEXT[]
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_tag_name TEXT;
    v_tag_id INTEGER;
BEGIN
    FOREACH v_tag_name IN ARRAY p_tags
    LOOP
        SELECT id INTO v_tag_id
        FROM tags
        WHERE name = v_tag_name
        LIMIT 1;

        IF v_tag_id IS NULL THEN
            INSERT INTO tags (user_id, type, name)
            VALUES (p_user_id, 'general', v_tag_name)
            RETURNING id INTO v_tag_id;
        END IF;

        INSERT INTO listing_tags (listing_id, tag_id)
        VALUES (p_listing_id, v_tag_id);
    END LOOP;
END;
$$;




-- ===== DEMO =====

INSERT INTO users (email, name, level) VALUES ('admin@demo.org', 'admin', 'admin');
INSERT INTO users (email, name) VALUES ('demo@example.com', 'demo');
-- won't work because of invalid characters
-- INSERT INTO users (email, name) VALUES ('bad@example.com', '');
-- INSERT INTO users (email, name) VALUES ('bad@example.com', 'user name');

SELECT * FROM users;

-- won't work because user isn't admin
-- INSERT INTO events (user_id, name, currency, hours) VALUES (2, 'comiket_103', 'JPY', '{[2023-12-30 10:00:00+09, 2023-12-30 17:00:00+09], [2023-12-31 10:00:00+09, 2023-12-31 16:00:00+09]}');
INSERT INTO events (user_id, name, currency, hours) VALUES (1, 'comiket_103', 'JPY', '{[2023-12-30 10:00:00+09, 2023-12-30 17:00:00+09], [2023-12-31 10:00:00+09, 2023-12-31 16:00:00+09]}');

SELECT * FROM events;

-- won't work because user isn't verified
-- INSERT INTO merchants (user_id, name, urls) VALUES (2, 'rimukoro', 'twitter=>https://x.com/rimukoro');
UPDATE users SET level = 'verified' WHERE users.id = 2;
SELECT * FROM users WHERE users.id = 2;
INSERT INTO merchants (user_id, name, urls) VALUES (2, 'rimukoro', 'twitter=>https://x.com/rimukoro');

INSERT INTO listings (user_id, event_id, merchant_id, price) VALUES (2, 1, 1, 1500);

SELECT l.id, l.price, e.currency FROM listings l
JOIN events e ON l.event_id = e.id;

INSERT INTO tags (user_id, type, name) VALUES (2, 'general', 'sticker');
-- won't work because name is UNIQUE
-- INSERT INTO tags (user_id, type, name) VALUES (2, 'general', 'sticker');
INSERT INTO tags (user_id, type, name) VALUES (1, 'general', 'chibi');

CALL insert_listing_tags(2, 1, '{sticker, chibi, halo}');
SELECT * FROM listing_tags;
SELECT * FROM tags;

INSERT INTO comments (user_id, listing_id, content) VALUES (2, 1, 'cool comment');
SELECT * FROM comment_scores;

INSERT INTO comment_votes (user_id, comment_id, value) VALUES (1, 1, -1);
SELECT * FROM comments c
JOIN comment_scores cs ON c.id = comment_id;
